{-# LANGUAGE DeriveGeneric     #-}
{-# LANGUAGE DeriveAnyClass    #-}
{-# LANGUAGE DataKinds         #-}
{-# LANGUAGE GADTs             #-}
{-# LANGUAGE TypeApplications  #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-- | Generated by Haskell protocol buffer compiler. DO NOT EDIT!
module Proto.Mqtt where
import qualified Prelude as Hs
import qualified Proto3.Suite.Class as HsProtobuf
import qualified Proto3.Suite.DotProto as HsProtobuf
import qualified Proto3.Suite.JSONPB as HsJSONPB
import Proto3.Suite.JSONPB ((.=), (.:))
import qualified Proto3.Suite.Types as HsProtobuf
import qualified Proto3.Wire as HsProtobuf
import qualified Control.Applicative as Hs
import Control.Applicative ((<*>), (<|>), (<$>))
import qualified Control.DeepSeq as Hs
import qualified Control.Monad as Hs
import qualified Data.ByteString as Hs
import qualified Data.Coerce as Hs
import qualified Data.Int as Hs (Int16, Int32, Int64)
import qualified Data.List.NonEmpty as Hs (NonEmpty(..))
import qualified Data.Map as Hs (Map, mapKeysMonotonic)
import qualified Data.Proxy as Proxy
import qualified Data.String as Hs (fromString)
import qualified Data.Text.Lazy as Hs (Text)
import qualified Data.Vector as Hs (Vector)
import qualified Data.Word as Hs (Word16, Word32, Word64)
import qualified GHC.Enum as Hs
import qualified GHC.Generics as Hs
import qualified Unsafe.Coerce as Hs
 
data RCError = RCErrorUnknownError
             | RCErrorNoParseWireType
             | RCErrorNoParseBinary
             | RCErrorNoParseEmbedded
             | RCErrorIOGRPCCallOk
             | RCErrorIOGRPCCallError
             | RCErrorIOGRPCCallNotOnServer
             | RCErrorIOGRPCCallNotOnClient
             | RCErrorIOGRPCCallAlreadyAccepted
             | RCErrorIOGRPCCallAlreadyInvoked
             | RCErrorIOGRPCCallNotInvoked
             | RCErrorIOGRPCCallAlreadyFinished
             | RCErrorIOGRPCCallTooManyOperations
             | RCErrorIOGRPCCallInvalidFlags
             | RCErrorIOGRPCCallInvalidMetadata
             | RCErrorIOGRPCCallInvalidMessage
             | RCErrorIOGRPCCallNotServerCompletionQueue
             | RCErrorIOGRPCCallBatchTooBig
             | RCErrorIOGRPCCallPayloadTypeMismatch
             | RCErrorIOGRPCCallCompletionQueueShutdown
             | RCErrorIOGRPCTimeout
             | RCErrorIOGRPCShutdown
             | RCErrorIOGRPCShutdownFailure
             | RCErrorIOGRPCBadStatusCode
             | RCErrorIOGRPCDecode
             | RCErrorIOGRPCInternalUnexpectedRecv
             | RCErrorIOGRPCHandlerException
             | RCErrorMQTTFailure
             deriving (Hs.Show, Hs.Eq, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named RCError where
        nameOf _ = (Hs.fromString "RCError")
 
instance HsProtobuf.HasDefault RCError
 
instance Hs.Bounded RCError where
        minBound = RCErrorUnknownError
        maxBound = RCErrorMQTTFailure
 
instance Hs.Ord RCError where
        compare x y
          = Hs.compare (HsProtobuf.fromProtoEnum x)
              (HsProtobuf.fromProtoEnum y)
 
instance HsProtobuf.ProtoEnum RCError where
        toProtoEnumMay 0 = Hs.Just RCErrorUnknownError
        toProtoEnumMay 1 = Hs.Just RCErrorNoParseWireType
        toProtoEnumMay 2 = Hs.Just RCErrorNoParseBinary
        toProtoEnumMay 3 = Hs.Just RCErrorNoParseEmbedded
        toProtoEnumMay 4 = Hs.Just RCErrorIOGRPCCallOk
        toProtoEnumMay 5 = Hs.Just RCErrorIOGRPCCallError
        toProtoEnumMay 6 = Hs.Just RCErrorIOGRPCCallNotOnServer
        toProtoEnumMay 7 = Hs.Just RCErrorIOGRPCCallNotOnClient
        toProtoEnumMay 8 = Hs.Just RCErrorIOGRPCCallAlreadyAccepted
        toProtoEnumMay 9 = Hs.Just RCErrorIOGRPCCallAlreadyInvoked
        toProtoEnumMay 10 = Hs.Just RCErrorIOGRPCCallNotInvoked
        toProtoEnumMay 11 = Hs.Just RCErrorIOGRPCCallAlreadyFinished
        toProtoEnumMay 12 = Hs.Just RCErrorIOGRPCCallTooManyOperations
        toProtoEnumMay 13 = Hs.Just RCErrorIOGRPCCallInvalidFlags
        toProtoEnumMay 14 = Hs.Just RCErrorIOGRPCCallInvalidMetadata
        toProtoEnumMay 15 = Hs.Just RCErrorIOGRPCCallInvalidMessage
        toProtoEnumMay 16
          = Hs.Just RCErrorIOGRPCCallNotServerCompletionQueue
        toProtoEnumMay 17 = Hs.Just RCErrorIOGRPCCallBatchTooBig
        toProtoEnumMay 18 = Hs.Just RCErrorIOGRPCCallPayloadTypeMismatch
        toProtoEnumMay 19
          = Hs.Just RCErrorIOGRPCCallCompletionQueueShutdown
        toProtoEnumMay 20 = Hs.Just RCErrorIOGRPCTimeout
        toProtoEnumMay 21 = Hs.Just RCErrorIOGRPCShutdown
        toProtoEnumMay 22 = Hs.Just RCErrorIOGRPCShutdownFailure
        toProtoEnumMay 23 = Hs.Just RCErrorIOGRPCBadStatusCode
        toProtoEnumMay 24 = Hs.Just RCErrorIOGRPCDecode
        toProtoEnumMay 25 = Hs.Just RCErrorIOGRPCInternalUnexpectedRecv
        toProtoEnumMay 26 = Hs.Just RCErrorIOGRPCHandlerException
        toProtoEnumMay 27 = Hs.Just RCErrorMQTTFailure
        toProtoEnumMay _ = Hs.Nothing
        fromProtoEnum (RCErrorUnknownError) = 0
        fromProtoEnum (RCErrorNoParseWireType) = 1
        fromProtoEnum (RCErrorNoParseBinary) = 2
        fromProtoEnum (RCErrorNoParseEmbedded) = 3
        fromProtoEnum (RCErrorIOGRPCCallOk) = 4
        fromProtoEnum (RCErrorIOGRPCCallError) = 5
        fromProtoEnum (RCErrorIOGRPCCallNotOnServer) = 6
        fromProtoEnum (RCErrorIOGRPCCallNotOnClient) = 7
        fromProtoEnum (RCErrorIOGRPCCallAlreadyAccepted) = 8
        fromProtoEnum (RCErrorIOGRPCCallAlreadyInvoked) = 9
        fromProtoEnum (RCErrorIOGRPCCallNotInvoked) = 10
        fromProtoEnum (RCErrorIOGRPCCallAlreadyFinished) = 11
        fromProtoEnum (RCErrorIOGRPCCallTooManyOperations) = 12
        fromProtoEnum (RCErrorIOGRPCCallInvalidFlags) = 13
        fromProtoEnum (RCErrorIOGRPCCallInvalidMetadata) = 14
        fromProtoEnum (RCErrorIOGRPCCallInvalidMessage) = 15
        fromProtoEnum (RCErrorIOGRPCCallNotServerCompletionQueue) = 16
        fromProtoEnum (RCErrorIOGRPCCallBatchTooBig) = 17
        fromProtoEnum (RCErrorIOGRPCCallPayloadTypeMismatch) = 18
        fromProtoEnum (RCErrorIOGRPCCallCompletionQueueShutdown) = 19
        fromProtoEnum (RCErrorIOGRPCTimeout) = 20
        fromProtoEnum (RCErrorIOGRPCShutdown) = 21
        fromProtoEnum (RCErrorIOGRPCShutdownFailure) = 22
        fromProtoEnum (RCErrorIOGRPCBadStatusCode) = 23
        fromProtoEnum (RCErrorIOGRPCDecode) = 24
        fromProtoEnum (RCErrorIOGRPCInternalUnexpectedRecv) = 25
        fromProtoEnum (RCErrorIOGRPCHandlerException) = 26
        fromProtoEnum (RCErrorMQTTFailure) = 27
 
instance HsJSONPB.ToJSONPB RCError where
        toJSONPB x _ = HsJSONPB.enumFieldString x
        toEncodingPB x _ = HsJSONPB.enumFieldEncoding x
 
instance HsJSONPB.FromJSONPB RCError where
        parseJSONPB (HsJSONPB.String "UnknownError")
          = Hs.pure RCErrorUnknownError
        parseJSONPB (HsJSONPB.String "NoParseWireType")
          = Hs.pure RCErrorNoParseWireType
        parseJSONPB (HsJSONPB.String "NoParseBinary")
          = Hs.pure RCErrorNoParseBinary
        parseJSONPB (HsJSONPB.String "NoParseEmbedded")
          = Hs.pure RCErrorNoParseEmbedded
        parseJSONPB (HsJSONPB.String "IOGRPCCallOk")
          = Hs.pure RCErrorIOGRPCCallOk
        parseJSONPB (HsJSONPB.String "IOGRPCCallError")
          = Hs.pure RCErrorIOGRPCCallError
        parseJSONPB (HsJSONPB.String "IOGRPCCallNotOnServer")
          = Hs.pure RCErrorIOGRPCCallNotOnServer
        parseJSONPB (HsJSONPB.String "IOGRPCCallNotOnClient")
          = Hs.pure RCErrorIOGRPCCallNotOnClient
        parseJSONPB (HsJSONPB.String "IOGRPCCallAlreadyAccepted")
          = Hs.pure RCErrorIOGRPCCallAlreadyAccepted
        parseJSONPB (HsJSONPB.String "IOGRPCCallAlreadyInvoked")
          = Hs.pure RCErrorIOGRPCCallAlreadyInvoked
        parseJSONPB (HsJSONPB.String "IOGRPCCallNotInvoked")
          = Hs.pure RCErrorIOGRPCCallNotInvoked
        parseJSONPB (HsJSONPB.String "IOGRPCCallAlreadyFinished")
          = Hs.pure RCErrorIOGRPCCallAlreadyFinished
        parseJSONPB (HsJSONPB.String "IOGRPCCallTooManyOperations")
          = Hs.pure RCErrorIOGRPCCallTooManyOperations
        parseJSONPB (HsJSONPB.String "IOGRPCCallInvalidFlags")
          = Hs.pure RCErrorIOGRPCCallInvalidFlags
        parseJSONPB (HsJSONPB.String "IOGRPCCallInvalidMetadata")
          = Hs.pure RCErrorIOGRPCCallInvalidMetadata
        parseJSONPB (HsJSONPB.String "IOGRPCCallInvalidMessage")
          = Hs.pure RCErrorIOGRPCCallInvalidMessage
        parseJSONPB (HsJSONPB.String "IOGRPCCallNotServerCompletionQueue")
          = Hs.pure RCErrorIOGRPCCallNotServerCompletionQueue
        parseJSONPB (HsJSONPB.String "IOGRPCCallBatchTooBig")
          = Hs.pure RCErrorIOGRPCCallBatchTooBig
        parseJSONPB (HsJSONPB.String "IOGRPCCallPayloadTypeMismatch")
          = Hs.pure RCErrorIOGRPCCallPayloadTypeMismatch
        parseJSONPB (HsJSONPB.String "IOGRPCCallCompletionQueueShutdown")
          = Hs.pure RCErrorIOGRPCCallCompletionQueueShutdown
        parseJSONPB (HsJSONPB.String "IOGRPCTimeout")
          = Hs.pure RCErrorIOGRPCTimeout
        parseJSONPB (HsJSONPB.String "IOGRPCShutdown")
          = Hs.pure RCErrorIOGRPCShutdown
        parseJSONPB (HsJSONPB.String "IOGRPCShutdownFailure")
          = Hs.pure RCErrorIOGRPCShutdownFailure
        parseJSONPB (HsJSONPB.String "IOGRPCBadStatusCode")
          = Hs.pure RCErrorIOGRPCBadStatusCode
        parseJSONPB (HsJSONPB.String "IOGRPCDecode")
          = Hs.pure RCErrorIOGRPCDecode
        parseJSONPB (HsJSONPB.String "IOGRPCInternalUnexpectedRecv")
          = Hs.pure RCErrorIOGRPCInternalUnexpectedRecv
        parseJSONPB (HsJSONPB.String "IOGRPCHandlerException")
          = Hs.pure RCErrorIOGRPCHandlerException
        parseJSONPB (HsJSONPB.String "MQTTFailure")
          = Hs.pure RCErrorMQTTFailure
        parseJSONPB v = (HsJSONPB.typeMismatch "RCError" v)
 
instance HsJSONPB.ToJSON RCError where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON RCError where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsProtobuf.Finite RCError
 
data RemoteClientError = RemoteClientError{remoteClientErrorErrorType
                                           :: HsProtobuf.Enumerated Proto.Mqtt.RCError,
                                           remoteClientErrorMessage :: Hs.Text,
                                           remoteClientErrorExtra ::
                                           Hs.Maybe RemoteClientErrorExtra}
                       deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named RemoteClientError where
        nameOf _ = (Hs.fromString "RemoteClientError")
 
instance HsProtobuf.HasDefault RemoteClientError
 
instance HsProtobuf.Message RemoteClientError where
        encodeMessage _
          RemoteClientError{remoteClientErrorErrorType =
                              remoteClientErrorErrorType,
                            remoteClientErrorMessage = remoteClientErrorMessage,
                            remoteClientErrorExtra = remoteClientErrorExtra}
          = (Hs.mconcat
               [(HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                   remoteClientErrorErrorType),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 2)
                   remoteClientErrorMessage),
                case remoteClientErrorExtra of
                    Hs.Nothing -> Hs.mempty
                    Hs.Just x
                      -> case x of
                             RemoteClientErrorExtraStatusCode y
                               -> (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 3)
                                     (HsProtobuf.ForceEmit y))
                             RemoteClientErrorExtraEmbeddedError y
                               -> (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 4)
                                     (Hs.coerce @(Hs.Maybe Proto.Mqtt.RemoteClientError)
                                        @(HsProtobuf.Nested Proto.Mqtt.RemoteClientError)
                                        (Hs.Just y)))])
        decodeMessage _
          = (Hs.pure RemoteClientError) <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 1))
              <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 2))
              <*>
              (HsProtobuf.oneof Hs.Nothing
                 [((HsProtobuf.FieldNumber 3),
                   (Hs.pure (Hs.Just Hs.. RemoteClientErrorExtraStatusCode)) <*>
                     HsProtobuf.decodeMessageField),
                  ((HsProtobuf.FieldNumber 4),
                   (Hs.pure (Hs.fmap RemoteClientErrorExtraEmbeddedError)) <*>
                     (Hs.coerce @(_ (HsProtobuf.Nested Proto.Mqtt.RemoteClientError))
                        @(_ (Hs.Maybe Proto.Mqtt.RemoteClientError))
                        HsProtobuf.decodeMessageField))])
        dotProto _
          = [(HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 1)
                (HsProtobuf.Prim (HsProtobuf.Named (HsProtobuf.Single "RCError")))
                (HsProtobuf.Single "error_type")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 2)
                (HsProtobuf.Prim HsProtobuf.String)
                (HsProtobuf.Single "message")
                []
                "")]
 
instance HsJSONPB.ToJSONPB RemoteClientError where
        toJSONPB (RemoteClientError f1 f2 f3_or_f4)
          = (HsJSONPB.object
               ["error_type" .= f1, "message" .= f2,
                (let encodeExtra
                       = (case f3_or_f4 of
                              Hs.Just (RemoteClientErrorExtraStatusCode f3)
                                -> (HsJSONPB.pair "status_code" f3)
                              Hs.Just (RemoteClientErrorExtraEmbeddedError f4)
                                -> (HsJSONPB.pair "embedded_error" f4)
                              Hs.Nothing -> Hs.mempty)
                   in
                   \ options ->
                     if HsJSONPB.optEmitNamedOneof options then
                       ("extra" .= (HsJSONPB.objectOrNull [encodeExtra] options)) options
                       else encodeExtra options)])
        toEncodingPB (RemoteClientError f1 f2 f3_or_f4)
          = (HsJSONPB.pairs
               ["error_type" .= f1, "message" .= f2,
                (let encodeExtra
                       = (case f3_or_f4 of
                              Hs.Just (RemoteClientErrorExtraStatusCode f3)
                                -> (HsJSONPB.pair "status_code" f3)
                              Hs.Just (RemoteClientErrorExtraEmbeddedError f4)
                                -> (HsJSONPB.pair "embedded_error" f4)
                              Hs.Nothing -> Hs.mempty)
                   in
                   \ options ->
                     if HsJSONPB.optEmitNamedOneof options then
                       ("extra" .= (HsJSONPB.pairsOrNull [encodeExtra] options)) options
                       else encodeExtra options)])
 
instance HsJSONPB.FromJSONPB RemoteClientError where
        parseJSONPB
          = (HsJSONPB.withObject "RemoteClientError"
               (\ obj ->
                  (Hs.pure RemoteClientError) <*> obj .: "error_type" <*>
                    obj .: "message"
                    <*>
                    (let parseExtra parseObj
                           = Hs.msum
                               [Hs.Just Hs.. RemoteClientErrorExtraStatusCode <$>
                                  (HsJSONPB.parseField parseObj "status_code"),
                                Hs.Just Hs.. RemoteClientErrorExtraEmbeddedError <$>
                                  (HsJSONPB.parseField parseObj "embedded_error"),
                                Hs.pure Hs.Nothing]
                       in
                       ((obj .: "extra") Hs.>>= (HsJSONPB.withObject "extra" parseExtra))
                         <|> (parseExtra obj))))
 
instance HsJSONPB.ToJSON RemoteClientError where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON RemoteClientError where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema RemoteClientError where
        declareNamedSchema _
          = do let declare_error_type = HsJSONPB.declareSchemaRef
               remoteClientErrorErrorType <- declare_error_type Proxy.Proxy
               let declare_message = HsJSONPB.declareSchemaRef
               remoteClientErrorMessage <- declare_message Proxy.Proxy
               let declare_extra = HsJSONPB.declareSchemaRef
               remoteClientErrorExtra <- declare_extra Proxy.Proxy
               let _ = Hs.pure RemoteClientError <*>
                         HsJSONPB.asProxy declare_error_type
                         <*> HsJSONPB.asProxy declare_message
                         <*> HsJSONPB.asProxy declare_extra
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "RemoteClientError",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("error_type", remoteClientErrorErrorType),
                                                        ("message", remoteClientErrorMessage),
                                                        ("extra", remoteClientErrorExtra)]}})
 
data RemoteClientErrorExtra = RemoteClientErrorExtraStatusCode Hs.Int32
                            | RemoteClientErrorExtraEmbeddedError Proto.Mqtt.RemoteClientError
                            deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named RemoteClientErrorExtra where
        nameOf _ = (Hs.fromString "RemoteClientErrorExtra")
 
instance HsJSONPB.ToSchema RemoteClientErrorExtra where
        declareNamedSchema _
          = do let declare_status_code = HsJSONPB.declareSchemaRef
               remoteClientErrorExtraStatusCode <- declare_status_code Proxy.Proxy
               let _ = Hs.pure RemoteClientErrorExtraStatusCode <*>
                         HsJSONPB.asProxy declare_status_code
               let declare_embedded_error = HsJSONPB.declareSchemaRef
               remoteClientErrorExtraEmbeddedError <- declare_embedded_error
                                                        Proxy.Proxy
               let _ = Hs.pure RemoteClientErrorExtraEmbeddedError <*>
                         HsJSONPB.asProxy declare_embedded_error
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "RemoteClientErrorExtra",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("status_code",
                                                         remoteClientErrorExtraStatusCode),
                                                        ("embedded_error",
                                                         remoteClientErrorExtraEmbeddedError)],
                                                   HsJSONPB._schemaMinProperties = Hs.Just 1,
                                                   HsJSONPB._schemaMaxProperties = Hs.Just 1}})
 
newtype List = List{listValue :: Hs.Vector Hs.ByteString}
               deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named List where
        nameOf _ = (Hs.fromString "List")
 
instance HsProtobuf.HasDefault List
 
instance HsProtobuf.Message List where
        encodeMessage _ List{listValue = listValue}
          = (Hs.mconcat
               [(HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                   (Hs.coerce @(Hs.Vector Hs.ByteString)
                      @(HsProtobuf.UnpackedVec Hs.ByteString)
                      listValue))])
        decodeMessage _
          = (Hs.pure List) <*>
              (Hs.coerce @(_ (HsProtobuf.UnpackedVec Hs.ByteString))
                 @(_ (Hs.Vector Hs.ByteString))
                 (HsProtobuf.at HsProtobuf.decodeMessageField
                    (HsProtobuf.FieldNumber 1)))
        dotProto _
          = [(HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 1)
                (HsProtobuf.Repeated HsProtobuf.Bytes)
                (HsProtobuf.Single "value")
                []
                "")]
 
instance HsJSONPB.ToJSONPB List where
        toJSONPB (List f1) = (HsJSONPB.object ["value" .= f1])
        toEncodingPB (List f1) = (HsJSONPB.pairs ["value" .= f1])
 
instance HsJSONPB.FromJSONPB List where
        parseJSONPB
          = (HsJSONPB.withObject "List"
               (\ obj -> (Hs.pure List) <*> obj .: "value"))
 
instance HsJSONPB.ToJSON List where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON List where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema List where
        declareNamedSchema _
          = do let declare_value = HsJSONPB.declareSchemaRef
               listValue <- declare_value Proxy.Proxy
               let _ = Hs.pure List <*> HsJSONPB.asProxy declare_value
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName = Hs.Just "List",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("value", listValue)]}})
 
newtype MetadataMap = MetadataMap{metadataMapValue ::
                                  Hs.Map Hs.Text (Hs.Maybe Proto.Mqtt.List)}
                      deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named MetadataMap where
        nameOf _ = (Hs.fromString "MetadataMap")
 
instance HsProtobuf.HasDefault MetadataMap
 
instance HsProtobuf.Message MetadataMap where
        encodeMessage _ MetadataMap{metadataMapValue = metadataMapValue}
          = (Hs.mconcat
               [(HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                   (Hs.unsafeCoerce @(Hs.Map Hs.Text (Hs.Maybe Proto.Mqtt.List))
                      @(Hs.Map Hs.Text (HsProtobuf.Nested Proto.Mqtt.List))
                      metadataMapValue))])
        decodeMessage _
          = (Hs.pure MetadataMap) <*>
              (Hs.unsafeCoerce
                 @(_ (Hs.Map Hs.Text (HsProtobuf.Nested Proto.Mqtt.List)))
                 @(_ (Hs.Map Hs.Text (Hs.Maybe Proto.Mqtt.List)))
                 (HsProtobuf.at HsProtobuf.decodeMessageField
                    (HsProtobuf.FieldNumber 1)))
        dotProto _
          = [(HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 1)
                (HsProtobuf.Map HsProtobuf.String
                   (HsProtobuf.Named (HsProtobuf.Single "List")))
                (HsProtobuf.Single "value")
                []
                "")]
 
instance HsJSONPB.ToJSONPB MetadataMap where
        toJSONPB (MetadataMap f1) = (HsJSONPB.object ["value" .= f1])
        toEncodingPB (MetadataMap f1) = (HsJSONPB.pairs ["value" .= f1])
 
instance HsJSONPB.FromJSONPB MetadataMap where
        parseJSONPB
          = (HsJSONPB.withObject "MetadataMap"
               (\ obj -> (Hs.pure MetadataMap) <*> obj .: "value"))
 
instance HsJSONPB.ToJSON MetadataMap where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON MetadataMap where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema MetadataMap where
        declareNamedSchema _
          = do let declare_value = HsJSONPB.declareSchemaRef
               metadataMapValue <- declare_value Proxy.Proxy
               let _ = Hs.pure MetadataMap <*> HsJSONPB.asProxy declare_value
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "MetadataMap",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("value", metadataMapValue)]}})
 
data SequencedResponse = SequencedResponse{sequencedResponsePayload
                                           :: Hs.ByteString,
                                           sequencedResponseSequenceNum :: Hs.Int32}
                       deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named SequencedResponse where
        nameOf _ = (Hs.fromString "SequencedResponse")
 
instance HsProtobuf.HasDefault SequencedResponse
 
instance HsProtobuf.Message SequencedResponse where
        encodeMessage _
          SequencedResponse{sequencedResponsePayload =
                              sequencedResponsePayload,
                            sequencedResponseSequenceNum = sequencedResponseSequenceNum}
          = (Hs.mconcat
               [(HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                   sequencedResponsePayload),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 2)
                   sequencedResponseSequenceNum)])
        decodeMessage _
          = (Hs.pure SequencedResponse) <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 1))
              <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 2))
        dotProto _
          = [(HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 1)
                (HsProtobuf.Prim HsProtobuf.Bytes)
                (HsProtobuf.Single "payload")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 2)
                (HsProtobuf.Prim HsProtobuf.Int32)
                (HsProtobuf.Single "sequence_num")
                []
                "")]
 
instance HsJSONPB.ToJSONPB SequencedResponse where
        toJSONPB (SequencedResponse f1 f2)
          = (HsJSONPB.object ["payload" .= f1, "sequence_num" .= f2])
        toEncodingPB (SequencedResponse f1 f2)
          = (HsJSONPB.pairs ["payload" .= f1, "sequence_num" .= f2])
 
instance HsJSONPB.FromJSONPB SequencedResponse where
        parseJSONPB
          = (HsJSONPB.withObject "SequencedResponse"
               (\ obj ->
                  (Hs.pure SequencedResponse) <*> obj .: "payload" <*>
                    obj .: "sequence_num"))
 
instance HsJSONPB.ToJSON SequencedResponse where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON SequencedResponse where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema SequencedResponse where
        declareNamedSchema _
          = do let declare_payload = HsJSONPB.declareSchemaRef
               sequencedResponsePayload <- declare_payload Proxy.Proxy
               let declare_sequence_num = HsJSONPB.declareSchemaRef
               sequencedResponseSequenceNum <- declare_sequence_num Proxy.Proxy
               let _ = Hs.pure SequencedResponse <*>
                         HsJSONPB.asProxy declare_payload
                         <*> HsJSONPB.asProxy declare_sequence_num
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "SequencedResponse",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("payload", sequencedResponsePayload),
                                                        ("sequence_num",
                                                         sequencedResponseSequenceNum)]}})
 
newtype WrappedStreamChunk = WrappedStreamChunk{wrappedStreamChunkOrError
                                                :: Hs.Maybe WrappedStreamChunkOrError}
                             deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named WrappedStreamChunk where
        nameOf _ = (Hs.fromString "WrappedStreamChunk")
 
instance HsProtobuf.HasDefault WrappedStreamChunk
 
instance HsProtobuf.Message WrappedStreamChunk where
        encodeMessage _
          WrappedStreamChunk{wrappedStreamChunkOrError =
                               wrappedStreamChunkOrError}
          = (Hs.mconcat
               [case wrappedStreamChunkOrError of
                    Hs.Nothing -> Hs.mempty
                    Hs.Just x
                      -> case x of
                             WrappedStreamChunkOrErrorValue y
                               -> (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                                     (HsProtobuf.ForceEmit y))
                             WrappedStreamChunkOrErrorError y
                               -> (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 2)
                                     (Hs.coerce @(Hs.Maybe Proto.Mqtt.RemoteClientError)
                                        @(HsProtobuf.Nested Proto.Mqtt.RemoteClientError)
                                        (Hs.Just y)))])
        decodeMessage _
          = (Hs.pure WrappedStreamChunk) <*>
              (HsProtobuf.oneof Hs.Nothing
                 [((HsProtobuf.FieldNumber 1),
                   (Hs.pure (Hs.Just Hs.. WrappedStreamChunkOrErrorValue)) <*>
                     HsProtobuf.decodeMessageField),
                  ((HsProtobuf.FieldNumber 2),
                   (Hs.pure (Hs.fmap WrappedStreamChunkOrErrorError)) <*>
                     (Hs.coerce @(_ (HsProtobuf.Nested Proto.Mqtt.RemoteClientError))
                        @(_ (Hs.Maybe Proto.Mqtt.RemoteClientError))
                        HsProtobuf.decodeMessageField))])
        dotProto _ = []
 
instance HsJSONPB.ToJSONPB WrappedStreamChunk where
        toJSONPB (WrappedStreamChunk f1_or_f2)
          = (HsJSONPB.object
               [(let encodeOr_error
                       = (case f1_or_f2 of
                              Hs.Just (WrappedStreamChunkOrErrorValue f1)
                                -> (HsJSONPB.pair "value" f1)
                              Hs.Just (WrappedStreamChunkOrErrorError f2)
                                -> (HsJSONPB.pair "error" f2)
                              Hs.Nothing -> Hs.mempty)
                   in
                   \ options ->
                     if HsJSONPB.optEmitNamedOneof options then
                       ("or_error" .= (HsJSONPB.objectOrNull [encodeOr_error] options))
                         options
                       else encodeOr_error options)])
        toEncodingPB (WrappedStreamChunk f1_or_f2)
          = (HsJSONPB.pairs
               [(let encodeOr_error
                       = (case f1_or_f2 of
                              Hs.Just (WrappedStreamChunkOrErrorValue f1)
                                -> (HsJSONPB.pair "value" f1)
                              Hs.Just (WrappedStreamChunkOrErrorError f2)
                                -> (HsJSONPB.pair "error" f2)
                              Hs.Nothing -> Hs.mempty)
                   in
                   \ options ->
                     if HsJSONPB.optEmitNamedOneof options then
                       ("or_error" .= (HsJSONPB.pairsOrNull [encodeOr_error] options))
                         options
                       else encodeOr_error options)])
 
instance HsJSONPB.FromJSONPB WrappedStreamChunk where
        parseJSONPB
          = (HsJSONPB.withObject "WrappedStreamChunk"
               (\ obj ->
                  (Hs.pure WrappedStreamChunk) <*>
                    (let parseOr_error parseObj
                           = Hs.msum
                               [Hs.Just Hs.. WrappedStreamChunkOrErrorValue <$>
                                  (HsJSONPB.parseField parseObj "value"),
                                Hs.Just Hs.. WrappedStreamChunkOrErrorError <$>
                                  (HsJSONPB.parseField parseObj "error"),
                                Hs.pure Hs.Nothing]
                       in
                       ((obj .: "or_error") Hs.>>=
                          (HsJSONPB.withObject "or_error" parseOr_error))
                         <|> (parseOr_error obj))))
 
instance HsJSONPB.ToJSON WrappedStreamChunk where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON WrappedStreamChunk where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema WrappedStreamChunk where
        declareNamedSchema _
          = do let declare_or_error = HsJSONPB.declareSchemaRef
               wrappedStreamChunkOrError <- declare_or_error Proxy.Proxy
               let _ = Hs.pure WrappedStreamChunk <*>
                         HsJSONPB.asProxy declare_or_error
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "WrappedStreamChunk",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("or_error", wrappedStreamChunkOrError)]}})
 
data WrappedStreamChunkOrError = WrappedStreamChunkOrErrorValue Hs.ByteString
                               | WrappedStreamChunkOrErrorError Proto.Mqtt.RemoteClientError
                               deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named WrappedStreamChunkOrError where
        nameOf _ = (Hs.fromString "WrappedStreamChunkOrError")
 
instance HsJSONPB.ToSchema WrappedStreamChunkOrError where
        declareNamedSchema _
          = do let declare_value = HsJSONPB.declareSchemaRef
               wrappedStreamChunkOrErrorValue <- declare_value Proxy.Proxy
               let _ = Hs.pure WrappedStreamChunkOrErrorValue <*>
                         HsJSONPB.asProxy declare_value
               let declare_error = HsJSONPB.declareSchemaRef
               wrappedStreamChunkOrErrorError <- declare_error Proxy.Proxy
               let _ = Hs.pure WrappedStreamChunkOrErrorError <*>
                         HsJSONPB.asProxy declare_error
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "WrappedStreamChunkOrError",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("value", wrappedStreamChunkOrErrorValue),
                                                        ("error", wrappedStreamChunkOrErrorError)],
                                                   HsJSONPB._schemaMinProperties = Hs.Just 1,
                                                   HsJSONPB._schemaMaxProperties = Hs.Just 1}})
 
newtype WrappedStreamResponse = WrappedStreamResponse{wrappedStreamResponseOrError
                                                      :: Hs.Maybe WrappedStreamResponseOrError}
                                deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named WrappedStreamResponse where
        nameOf _ = (Hs.fromString "WrappedStreamResponse")
 
instance HsProtobuf.HasDefault WrappedStreamResponse
 
instance HsProtobuf.Message WrappedStreamResponse where
        encodeMessage _
          WrappedStreamResponse{wrappedStreamResponseOrError =
                                  wrappedStreamResponseOrError}
          = (Hs.mconcat
               [case wrappedStreamResponseOrError of
                    Hs.Nothing -> Hs.mempty
                    Hs.Just x
                      -> case x of
                             WrappedStreamResponseOrErrorResponse y
                               -> (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                                     (Hs.coerce @(Hs.Maybe Proto.Mqtt.StreamResponse)
                                        @(HsProtobuf.Nested Proto.Mqtt.StreamResponse)
                                        (Hs.Just y)))
                             WrappedStreamResponseOrErrorError y
                               -> (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 2)
                                     (Hs.coerce @(Hs.Maybe Proto.Mqtt.RemoteClientError)
                                        @(HsProtobuf.Nested Proto.Mqtt.RemoteClientError)
                                        (Hs.Just y)))])
        decodeMessage _
          = (Hs.pure WrappedStreamResponse) <*>
              (HsProtobuf.oneof Hs.Nothing
                 [((HsProtobuf.FieldNumber 1),
                   (Hs.pure (Hs.fmap WrappedStreamResponseOrErrorResponse)) <*>
                     (Hs.coerce @(_ (HsProtobuf.Nested Proto.Mqtt.StreamResponse))
                        @(_ (Hs.Maybe Proto.Mqtt.StreamResponse))
                        HsProtobuf.decodeMessageField)),
                  ((HsProtobuf.FieldNumber 2),
                   (Hs.pure (Hs.fmap WrappedStreamResponseOrErrorError)) <*>
                     (Hs.coerce @(_ (HsProtobuf.Nested Proto.Mqtt.RemoteClientError))
                        @(_ (Hs.Maybe Proto.Mqtt.RemoteClientError))
                        HsProtobuf.decodeMessageField))])
        dotProto _ = []
 
instance HsJSONPB.ToJSONPB WrappedStreamResponse where
        toJSONPB (WrappedStreamResponse f1_or_f2)
          = (HsJSONPB.object
               [(let encodeOr_error
                       = (case f1_or_f2 of
                              Hs.Just (WrappedStreamResponseOrErrorResponse f1)
                                -> (HsJSONPB.pair "response" f1)
                              Hs.Just (WrappedStreamResponseOrErrorError f2)
                                -> (HsJSONPB.pair "error" f2)
                              Hs.Nothing -> Hs.mempty)
                   in
                   \ options ->
                     if HsJSONPB.optEmitNamedOneof options then
                       ("or_error" .= (HsJSONPB.objectOrNull [encodeOr_error] options))
                         options
                       else encodeOr_error options)])
        toEncodingPB (WrappedStreamResponse f1_or_f2)
          = (HsJSONPB.pairs
               [(let encodeOr_error
                       = (case f1_or_f2 of
                              Hs.Just (WrappedStreamResponseOrErrorResponse f1)
                                -> (HsJSONPB.pair "response" f1)
                              Hs.Just (WrappedStreamResponseOrErrorError f2)
                                -> (HsJSONPB.pair "error" f2)
                              Hs.Nothing -> Hs.mempty)
                   in
                   \ options ->
                     if HsJSONPB.optEmitNamedOneof options then
                       ("or_error" .= (HsJSONPB.pairsOrNull [encodeOr_error] options))
                         options
                       else encodeOr_error options)])
 
instance HsJSONPB.FromJSONPB WrappedStreamResponse where
        parseJSONPB
          = (HsJSONPB.withObject "WrappedStreamResponse"
               (\ obj ->
                  (Hs.pure WrappedStreamResponse) <*>
                    (let parseOr_error parseObj
                           = Hs.msum
                               [Hs.Just Hs.. WrappedStreamResponseOrErrorResponse <$>
                                  (HsJSONPB.parseField parseObj "response"),
                                Hs.Just Hs.. WrappedStreamResponseOrErrorError <$>
                                  (HsJSONPB.parseField parseObj "error"),
                                Hs.pure Hs.Nothing]
                       in
                       ((obj .: "or_error") Hs.>>=
                          (HsJSONPB.withObject "or_error" parseOr_error))
                         <|> (parseOr_error obj))))
 
instance HsJSONPB.ToJSON WrappedStreamResponse where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON WrappedStreamResponse where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema WrappedStreamResponse where
        declareNamedSchema _
          = do let declare_or_error = HsJSONPB.declareSchemaRef
               wrappedStreamResponseOrError <- declare_or_error Proxy.Proxy
               let _ = Hs.pure WrappedStreamResponse <*>
                         HsJSONPB.asProxy declare_or_error
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "WrappedStreamResponse",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("or_error",
                                                         wrappedStreamResponseOrError)]}})
 
data WrappedStreamResponseOrError = WrappedStreamResponseOrErrorResponse Proto.Mqtt.StreamResponse
                                  | WrappedStreamResponseOrErrorError Proto.Mqtt.RemoteClientError
                                  deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named WrappedStreamResponseOrError where
        nameOf _ = (Hs.fromString "WrappedStreamResponseOrError")
 
instance HsJSONPB.ToSchema WrappedStreamResponseOrError where
        declareNamedSchema _
          = do let declare_response = HsJSONPB.declareSchemaRef
               wrappedStreamResponseOrErrorResponse <- declare_response
                                                         Proxy.Proxy
               let _ = Hs.pure WrappedStreamResponseOrErrorResponse <*>
                         HsJSONPB.asProxy declare_response
               let declare_error = HsJSONPB.declareSchemaRef
               wrappedStreamResponseOrErrorError <- declare_error Proxy.Proxy
               let _ = Hs.pure WrappedStreamResponseOrErrorError <*>
                         HsJSONPB.asProxy declare_error
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "WrappedStreamResponseOrError",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("response",
                                                         wrappedStreamResponseOrErrorResponse),
                                                        ("error",
                                                         wrappedStreamResponseOrErrorError)],
                                                   HsJSONPB._schemaMinProperties = Hs.Just 1,
                                                   HsJSONPB._schemaMaxProperties = Hs.Just 1}})
 
data StreamResponse = StreamResponse{streamResponseMetamap ::
                                     Hs.Maybe Proto.Mqtt.MetadataMap,
                                     streamResponseResponseCode :: Hs.Int32,
                                     streamResponseDetails :: Hs.Text}
                    deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named StreamResponse where
        nameOf _ = (Hs.fromString "StreamResponse")
 
instance HsProtobuf.HasDefault StreamResponse
 
instance HsProtobuf.Message StreamResponse where
        encodeMessage _
          StreamResponse{streamResponseMetamap = streamResponseMetamap,
                         streamResponseResponseCode = streamResponseResponseCode,
                         streamResponseDetails = streamResponseDetails}
          = (Hs.mconcat
               [(HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                   (Hs.coerce @(Hs.Maybe Proto.Mqtt.MetadataMap)
                      @(HsProtobuf.Nested Proto.Mqtt.MetadataMap)
                      streamResponseMetamap)),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 2)
                   streamResponseResponseCode),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 3)
                   streamResponseDetails)])
        decodeMessage _
          = (Hs.pure StreamResponse) <*>
              (Hs.coerce @(_ (HsProtobuf.Nested Proto.Mqtt.MetadataMap))
                 @(_ (Hs.Maybe Proto.Mqtt.MetadataMap))
                 (HsProtobuf.at HsProtobuf.decodeMessageField
                    (HsProtobuf.FieldNumber 1)))
              <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 2))
              <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 3))
        dotProto _
          = [(HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 1)
                (HsProtobuf.Prim
                   (HsProtobuf.Named (HsProtobuf.Single "MetadataMap")))
                (HsProtobuf.Single "metamap")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 2)
                (HsProtobuf.Prim HsProtobuf.Int32)
                (HsProtobuf.Single "response_code")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 3)
                (HsProtobuf.Prim HsProtobuf.String)
                (HsProtobuf.Single "details")
                []
                "")]
 
instance HsJSONPB.ToJSONPB StreamResponse where
        toJSONPB (StreamResponse f1 f2 f3)
          = (HsJSONPB.object
               ["metamap" .= f1, "response_code" .= f2, "details" .= f3])
        toEncodingPB (StreamResponse f1 f2 f3)
          = (HsJSONPB.pairs
               ["metamap" .= f1, "response_code" .= f2, "details" .= f3])
 
instance HsJSONPB.FromJSONPB StreamResponse where
        parseJSONPB
          = (HsJSONPB.withObject "StreamResponse"
               (\ obj ->
                  (Hs.pure StreamResponse) <*> obj .: "metamap" <*>
                    obj .: "response_code"
                    <*> obj .: "details"))
 
instance HsJSONPB.ToJSON StreamResponse where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON StreamResponse where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema StreamResponse where
        declareNamedSchema _
          = do let declare_metamap = HsJSONPB.declareSchemaRef
               streamResponseMetamap <- declare_metamap Proxy.Proxy
               let declare_response_code = HsJSONPB.declareSchemaRef
               streamResponseResponseCode <- declare_response_code Proxy.Proxy
               let declare_details = HsJSONPB.declareSchemaRef
               streamResponseDetails <- declare_details Proxy.Proxy
               let _ = Hs.pure StreamResponse <*> HsJSONPB.asProxy declare_metamap
                         <*> HsJSONPB.asProxy declare_response_code
                         <*> HsJSONPB.asProxy declare_details
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "StreamResponse",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("metamap", streamResponseMetamap),
                                                        ("response_code",
                                                         streamResponseResponseCode),
                                                        ("details", streamResponseDetails)]}})
 
data WrappedMQTTRequest = WrappedMQTTRequest{wrappedMQTTRequestResponseTopic
                                             :: Hs.Text,
                                             wrappedMQTTRequestTimeout :: Hs.Int64,
                                             wrappedMQTTRequestMetamap ::
                                             Hs.Maybe Proto.Mqtt.MetadataMap,
                                             wrappedMQTTRequestPayload :: Hs.ByteString}
                        deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named WrappedMQTTRequest where
        nameOf _ = (Hs.fromString "WrappedMQTTRequest")
 
instance HsProtobuf.HasDefault WrappedMQTTRequest
 
instance HsProtobuf.Message WrappedMQTTRequest where
        encodeMessage _
          WrappedMQTTRequest{wrappedMQTTRequestResponseTopic =
                               wrappedMQTTRequestResponseTopic,
                             wrappedMQTTRequestTimeout = wrappedMQTTRequestTimeout,
                             wrappedMQTTRequestMetamap = wrappedMQTTRequestMetamap,
                             wrappedMQTTRequestPayload = wrappedMQTTRequestPayload}
          = (Hs.mconcat
               [(HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                   wrappedMQTTRequestResponseTopic),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 2)
                   wrappedMQTTRequestTimeout),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 3)
                   (Hs.coerce @(Hs.Maybe Proto.Mqtt.MetadataMap)
                      @(HsProtobuf.Nested Proto.Mqtt.MetadataMap)
                      wrappedMQTTRequestMetamap)),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 4)
                   wrappedMQTTRequestPayload)])
        decodeMessage _
          = (Hs.pure WrappedMQTTRequest) <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 1))
              <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 2))
              <*>
              (Hs.coerce @(_ (HsProtobuf.Nested Proto.Mqtt.MetadataMap))
                 @(_ (Hs.Maybe Proto.Mqtt.MetadataMap))
                 (HsProtobuf.at HsProtobuf.decodeMessageField
                    (HsProtobuf.FieldNumber 3)))
              <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 4))
        dotProto _
          = [(HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 1)
                (HsProtobuf.Prim HsProtobuf.String)
                (HsProtobuf.Single "response_topic")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 2)
                (HsProtobuf.Prim HsProtobuf.Int64)
                (HsProtobuf.Single "timeout")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 3)
                (HsProtobuf.Prim
                   (HsProtobuf.Named (HsProtobuf.Single "MetadataMap")))
                (HsProtobuf.Single "metamap")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 4)
                (HsProtobuf.Prim HsProtobuf.Bytes)
                (HsProtobuf.Single "payload")
                []
                "")]
 
instance HsJSONPB.ToJSONPB WrappedMQTTRequest where
        toJSONPB (WrappedMQTTRequest f1 f2 f3 f4)
          = (HsJSONPB.object
               ["response_topic" .= f1, "timeout" .= f2, "metamap" .= f3,
                "payload" .= f4])
        toEncodingPB (WrappedMQTTRequest f1 f2 f3 f4)
          = (HsJSONPB.pairs
               ["response_topic" .= f1, "timeout" .= f2, "metamap" .= f3,
                "payload" .= f4])
 
instance HsJSONPB.FromJSONPB WrappedMQTTRequest where
        parseJSONPB
          = (HsJSONPB.withObject "WrappedMQTTRequest"
               (\ obj ->
                  (Hs.pure WrappedMQTTRequest) <*> obj .: "response_topic" <*>
                    obj .: "timeout"
                    <*> obj .: "metamap"
                    <*> obj .: "payload"))
 
instance HsJSONPB.ToJSON WrappedMQTTRequest where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON WrappedMQTTRequest where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema WrappedMQTTRequest where
        declareNamedSchema _
          = do let declare_response_topic = HsJSONPB.declareSchemaRef
               wrappedMQTTRequestResponseTopic <- declare_response_topic
                                                    Proxy.Proxy
               let declare_timeout = HsJSONPB.declareSchemaRef
               wrappedMQTTRequestTimeout <- declare_timeout Proxy.Proxy
               let declare_metamap = HsJSONPB.declareSchemaRef
               wrappedMQTTRequestMetamap <- declare_metamap Proxy.Proxy
               let declare_payload = HsJSONPB.declareSchemaRef
               wrappedMQTTRequestPayload <- declare_payload Proxy.Proxy
               let _ = Hs.pure WrappedMQTTRequest <*>
                         HsJSONPB.asProxy declare_response_topic
                         <*> HsJSONPB.asProxy declare_timeout
                         <*> HsJSONPB.asProxy declare_metamap
                         <*> HsJSONPB.asProxy declare_payload
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "WrappedMQTTRequest",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("response_topic",
                                                         wrappedMQTTRequestResponseTopic),
                                                        ("timeout", wrappedMQTTRequestTimeout),
                                                        ("metamap", wrappedMQTTRequestMetamap),
                                                        ("payload", wrappedMQTTRequestPayload)]}})
 
newtype WrappedUnaryResponse = WrappedUnaryResponse{wrappedUnaryResponseOrErr
                                                    :: Hs.Maybe WrappedUnaryResponseOrErr}
                               deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named WrappedUnaryResponse where
        nameOf _ = (Hs.fromString "WrappedUnaryResponse")
 
instance HsProtobuf.HasDefault WrappedUnaryResponse
 
instance HsProtobuf.Message WrappedUnaryResponse where
        encodeMessage _
          WrappedUnaryResponse{wrappedUnaryResponseOrErr =
                                 wrappedUnaryResponseOrErr}
          = (Hs.mconcat
               [case wrappedUnaryResponseOrErr of
                    Hs.Nothing -> Hs.mempty
                    Hs.Just x
                      -> case x of
                             WrappedUnaryResponseOrErrResponse y
                               -> (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                                     (Hs.coerce @(Hs.Maybe Proto.Mqtt.UnaryResponse)
                                        @(HsProtobuf.Nested Proto.Mqtt.UnaryResponse)
                                        (Hs.Just y)))
                             WrappedUnaryResponseOrErrError y
                               -> (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 2)
                                     (Hs.coerce @(Hs.Maybe Proto.Mqtt.RemoteClientError)
                                        @(HsProtobuf.Nested Proto.Mqtt.RemoteClientError)
                                        (Hs.Just y)))])
        decodeMessage _
          = (Hs.pure WrappedUnaryResponse) <*>
              (HsProtobuf.oneof Hs.Nothing
                 [((HsProtobuf.FieldNumber 1),
                   (Hs.pure (Hs.fmap WrappedUnaryResponseOrErrResponse)) <*>
                     (Hs.coerce @(_ (HsProtobuf.Nested Proto.Mqtt.UnaryResponse))
                        @(_ (Hs.Maybe Proto.Mqtt.UnaryResponse))
                        HsProtobuf.decodeMessageField)),
                  ((HsProtobuf.FieldNumber 2),
                   (Hs.pure (Hs.fmap WrappedUnaryResponseOrErrError)) <*>
                     (Hs.coerce @(_ (HsProtobuf.Nested Proto.Mqtt.RemoteClientError))
                        @(_ (Hs.Maybe Proto.Mqtt.RemoteClientError))
                        HsProtobuf.decodeMessageField))])
        dotProto _ = []
 
instance HsJSONPB.ToJSONPB WrappedUnaryResponse where
        toJSONPB (WrappedUnaryResponse f1_or_f2)
          = (HsJSONPB.object
               [(let encodeOr_err
                       = (case f1_or_f2 of
                              Hs.Just (WrappedUnaryResponseOrErrResponse f1)
                                -> (HsJSONPB.pair "response" f1)
                              Hs.Just (WrappedUnaryResponseOrErrError f2)
                                -> (HsJSONPB.pair "error" f2)
                              Hs.Nothing -> Hs.mempty)
                   in
                   \ options ->
                     if HsJSONPB.optEmitNamedOneof options then
                       ("or_err" .= (HsJSONPB.objectOrNull [encodeOr_err] options))
                         options
                       else encodeOr_err options)])
        toEncodingPB (WrappedUnaryResponse f1_or_f2)
          = (HsJSONPB.pairs
               [(let encodeOr_err
                       = (case f1_or_f2 of
                              Hs.Just (WrappedUnaryResponseOrErrResponse f1)
                                -> (HsJSONPB.pair "response" f1)
                              Hs.Just (WrappedUnaryResponseOrErrError f2)
                                -> (HsJSONPB.pair "error" f2)
                              Hs.Nothing -> Hs.mempty)
                   in
                   \ options ->
                     if HsJSONPB.optEmitNamedOneof options then
                       ("or_err" .= (HsJSONPB.pairsOrNull [encodeOr_err] options)) options
                       else encodeOr_err options)])
 
instance HsJSONPB.FromJSONPB WrappedUnaryResponse where
        parseJSONPB
          = (HsJSONPB.withObject "WrappedUnaryResponse"
               (\ obj ->
                  (Hs.pure WrappedUnaryResponse) <*>
                    (let parseOr_err parseObj
                           = Hs.msum
                               [Hs.Just Hs.. WrappedUnaryResponseOrErrResponse <$>
                                  (HsJSONPB.parseField parseObj "response"),
                                Hs.Just Hs.. WrappedUnaryResponseOrErrError <$>
                                  (HsJSONPB.parseField parseObj "error"),
                                Hs.pure Hs.Nothing]
                       in
                       ((obj .: "or_err") Hs.>>=
                          (HsJSONPB.withObject "or_err" parseOr_err))
                         <|> (parseOr_err obj))))
 
instance HsJSONPB.ToJSON WrappedUnaryResponse where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON WrappedUnaryResponse where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema WrappedUnaryResponse where
        declareNamedSchema _
          = do let declare_or_err = HsJSONPB.declareSchemaRef
               wrappedUnaryResponseOrErr <- declare_or_err Proxy.Proxy
               let _ = Hs.pure WrappedUnaryResponse <*>
                         HsJSONPB.asProxy declare_or_err
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "WrappedUnaryResponse",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("or_err", wrappedUnaryResponseOrErr)]}})
 
data WrappedUnaryResponseOrErr = WrappedUnaryResponseOrErrResponse Proto.Mqtt.UnaryResponse
                               | WrappedUnaryResponseOrErrError Proto.Mqtt.RemoteClientError
                               deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named WrappedUnaryResponseOrErr where
        nameOf _ = (Hs.fromString "WrappedUnaryResponseOrErr")
 
instance HsJSONPB.ToSchema WrappedUnaryResponseOrErr where
        declareNamedSchema _
          = do let declare_response = HsJSONPB.declareSchemaRef
               wrappedUnaryResponseOrErrResponse <- declare_response Proxy.Proxy
               let _ = Hs.pure WrappedUnaryResponseOrErrResponse <*>
                         HsJSONPB.asProxy declare_response
               let declare_error = HsJSONPB.declareSchemaRef
               wrappedUnaryResponseOrErrError <- declare_error Proxy.Proxy
               let _ = Hs.pure WrappedUnaryResponseOrErrError <*>
                         HsJSONPB.asProxy declare_error
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "WrappedUnaryResponseOrErr",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("response",
                                                         wrappedUnaryResponseOrErrResponse),
                                                        ("error", wrappedUnaryResponseOrErrError)],
                                                   HsJSONPB._schemaMinProperties = Hs.Just 1,
                                                   HsJSONPB._schemaMaxProperties = Hs.Just 1}})
 
data UnaryResponse = UnaryResponse{unaryResponseBody ::
                                   Hs.ByteString,
                                   unaryResponseInitMetamap :: Hs.Maybe Proto.Mqtt.MetadataMap,
                                   unaryResponseTrailMetamap :: Hs.Maybe Proto.Mqtt.MetadataMap,
                                   unaryResponseResponseCode :: Hs.Int32,
                                   unaryResponseDetails :: Hs.Text}
                   deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named UnaryResponse where
        nameOf _ = (Hs.fromString "UnaryResponse")
 
instance HsProtobuf.HasDefault UnaryResponse
 
instance HsProtobuf.Message UnaryResponse where
        encodeMessage _
          UnaryResponse{unaryResponseBody = unaryResponseBody,
                        unaryResponseInitMetamap = unaryResponseInitMetamap,
                        unaryResponseTrailMetamap = unaryResponseTrailMetamap,
                        unaryResponseResponseCode = unaryResponseResponseCode,
                        unaryResponseDetails = unaryResponseDetails}
          = (Hs.mconcat
               [(HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                   unaryResponseBody),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 2)
                   (Hs.coerce @(Hs.Maybe Proto.Mqtt.MetadataMap)
                      @(HsProtobuf.Nested Proto.Mqtt.MetadataMap)
                      unaryResponseInitMetamap)),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 3)
                   (Hs.coerce @(Hs.Maybe Proto.Mqtt.MetadataMap)
                      @(HsProtobuf.Nested Proto.Mqtt.MetadataMap)
                      unaryResponseTrailMetamap)),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 4)
                   unaryResponseResponseCode),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 5)
                   unaryResponseDetails)])
        decodeMessage _
          = (Hs.pure UnaryResponse) <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 1))
              <*>
              (Hs.coerce @(_ (HsProtobuf.Nested Proto.Mqtt.MetadataMap))
                 @(_ (Hs.Maybe Proto.Mqtt.MetadataMap))
                 (HsProtobuf.at HsProtobuf.decodeMessageField
                    (HsProtobuf.FieldNumber 2)))
              <*>
              (Hs.coerce @(_ (HsProtobuf.Nested Proto.Mqtt.MetadataMap))
                 @(_ (Hs.Maybe Proto.Mqtt.MetadataMap))
                 (HsProtobuf.at HsProtobuf.decodeMessageField
                    (HsProtobuf.FieldNumber 3)))
              <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 4))
              <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 5))
        dotProto _
          = [(HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 1)
                (HsProtobuf.Prim HsProtobuf.Bytes)
                (HsProtobuf.Single "body")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 2)
                (HsProtobuf.Prim
                   (HsProtobuf.Named (HsProtobuf.Single "MetadataMap")))
                (HsProtobuf.Single "init_metamap")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 3)
                (HsProtobuf.Prim
                   (HsProtobuf.Named (HsProtobuf.Single "MetadataMap")))
                (HsProtobuf.Single "trail_metamap")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 4)
                (HsProtobuf.Prim HsProtobuf.Int32)
                (HsProtobuf.Single "response_code")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 5)
                (HsProtobuf.Prim HsProtobuf.String)
                (HsProtobuf.Single "details")
                []
                "")]
 
instance HsJSONPB.ToJSONPB UnaryResponse where
        toJSONPB (UnaryResponse f1 f2 f3 f4 f5)
          = (HsJSONPB.object
               ["body" .= f1, "init_metamap" .= f2, "trail_metamap" .= f3,
                "response_code" .= f4, "details" .= f5])
        toEncodingPB (UnaryResponse f1 f2 f3 f4 f5)
          = (HsJSONPB.pairs
               ["body" .= f1, "init_metamap" .= f2, "trail_metamap" .= f3,
                "response_code" .= f4, "details" .= f5])
 
instance HsJSONPB.FromJSONPB UnaryResponse where
        parseJSONPB
          = (HsJSONPB.withObject "UnaryResponse"
               (\ obj ->
                  (Hs.pure UnaryResponse) <*> obj .: "body" <*> obj .: "init_metamap"
                    <*> obj .: "trail_metamap"
                    <*> obj .: "response_code"
                    <*> obj .: "details"))
 
instance HsJSONPB.ToJSON UnaryResponse where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON UnaryResponse where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema UnaryResponse where
        declareNamedSchema _
          = do let declare_body = HsJSONPB.declareSchemaRef
               unaryResponseBody <- declare_body Proxy.Proxy
               let declare_init_metamap = HsJSONPB.declareSchemaRef
               unaryResponseInitMetamap <- declare_init_metamap Proxy.Proxy
               let declare_trail_metamap = HsJSONPB.declareSchemaRef
               unaryResponseTrailMetamap <- declare_trail_metamap Proxy.Proxy
               let declare_response_code = HsJSONPB.declareSchemaRef
               unaryResponseResponseCode <- declare_response_code Proxy.Proxy
               let declare_details = HsJSONPB.declareSchemaRef
               unaryResponseDetails <- declare_details Proxy.Proxy
               let _ = Hs.pure UnaryResponse <*> HsJSONPB.asProxy declare_body <*>
                         HsJSONPB.asProxy declare_init_metamap
                         <*> HsJSONPB.asProxy declare_trail_metamap
                         <*> HsJSONPB.asProxy declare_response_code
                         <*> HsJSONPB.asProxy declare_details
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "UnaryResponse",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("body", unaryResponseBody),
                                                        ("init_metamap", unaryResponseInitMetamap),
                                                        ("trail_metamap",
                                                         unaryResponseTrailMetamap),
                                                        ("response_code",
                                                         unaryResponseResponseCode),
                                                        ("details", unaryResponseDetails)]}})
 
data AuxControl = AuxControlUnknown
                | AuxControlAlive
                | AuxControlTerminate
                deriving (Hs.Show, Hs.Eq, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named AuxControl where
        nameOf _ = (Hs.fromString "AuxControl")
 
instance HsProtobuf.HasDefault AuxControl
 
instance Hs.Bounded AuxControl where
        minBound = AuxControlUnknown
        maxBound = AuxControlTerminate
 
instance Hs.Ord AuxControl where
        compare x y
          = Hs.compare (HsProtobuf.fromProtoEnum x)
              (HsProtobuf.fromProtoEnum y)
 
instance HsProtobuf.ProtoEnum AuxControl where
        toProtoEnumMay 0 = Hs.Just AuxControlUnknown
        toProtoEnumMay 1 = Hs.Just AuxControlAlive
        toProtoEnumMay 2 = Hs.Just AuxControlTerminate
        toProtoEnumMay _ = Hs.Nothing
        fromProtoEnum (AuxControlUnknown) = 0
        fromProtoEnum (AuxControlAlive) = 1
        fromProtoEnum (AuxControlTerminate) = 2
 
instance HsJSONPB.ToJSONPB AuxControl where
        toJSONPB x _ = HsJSONPB.enumFieldString x
        toEncodingPB x _ = HsJSONPB.enumFieldEncoding x
 
instance HsJSONPB.FromJSONPB AuxControl where
        parseJSONPB (HsJSONPB.String "Unknown") = Hs.pure AuxControlUnknown
        parseJSONPB (HsJSONPB.String "Alive") = Hs.pure AuxControlAlive
        parseJSONPB (HsJSONPB.String "Terminate")
          = Hs.pure AuxControlTerminate
        parseJSONPB v = (HsJSONPB.typeMismatch "AuxControl" v)
 
instance HsJSONPB.ToJSON AuxControl where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON AuxControl where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsProtobuf.Finite AuxControl
 
newtype AuxControlMessage = AuxControlMessage{auxControlMessageValue
                                              :: HsProtobuf.Enumerated Proto.Mqtt.AuxControl}
                            deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named AuxControlMessage where
        nameOf _ = (Hs.fromString "AuxControlMessage")
 
instance HsProtobuf.HasDefault AuxControlMessage
 
instance HsProtobuf.Message AuxControlMessage where
        encodeMessage _
          AuxControlMessage{auxControlMessageValue = auxControlMessageValue}
          = (Hs.mconcat
               [(HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                   auxControlMessageValue)])
        decodeMessage _
          = (Hs.pure AuxControlMessage) <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 1))
        dotProto _
          = [(HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 1)
                (HsProtobuf.Prim
                   (HsProtobuf.Named (HsProtobuf.Single "AuxControl")))
                (HsProtobuf.Single "value")
                []
                "")]
 
instance HsJSONPB.ToJSONPB AuxControlMessage where
        toJSONPB (AuxControlMessage f1) = (HsJSONPB.object ["value" .= f1])
        toEncodingPB (AuxControlMessage f1)
          = (HsJSONPB.pairs ["value" .= f1])
 
instance HsJSONPB.FromJSONPB AuxControlMessage where
        parseJSONPB
          = (HsJSONPB.withObject "AuxControlMessage"
               (\ obj -> (Hs.pure AuxControlMessage) <*> obj .: "value"))
 
instance HsJSONPB.ToJSON AuxControlMessage where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON AuxControlMessage where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema AuxControlMessage where
        declareNamedSchema _
          = do let declare_value = HsJSONPB.declareSchemaRef
               auxControlMessageValue <- declare_value Proxy.Proxy
               let _ = Hs.pure AuxControlMessage <*>
                         HsJSONPB.asProxy declare_value
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "AuxControlMessage",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("value", auxControlMessageValue)]}})